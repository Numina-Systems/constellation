# Machine Spirit Core Implementation Plan - Phase 5: Code Execution Runtime

**Goal:** Deno sandbox executor with IPC bridge, configurable permissions, timeout/size enforcement, and a tool bridge allowing agent-written code to call host-side tools.

**Architecture:** `CodeRuntime` port defines the execution interface. `DenoExecutor` adapter spawns Deno subprocesses with explicit permission flags, communicates via JSON-lines IPC over stdin/stdout. The Deno-side runtime script (`runtime.ts`) provides a `__callTool__` bridge function that tools stubs (generated by ToolRegistry) use to invoke host-side tools through the IPC channel.

**Tech Stack:** Bun (Bun.spawn for subprocess management), Deno 2.x (sandbox runtime with fine-grained permissions), JSON-lines IPC, TextLineStream from jsr:@std/streams

**Scope:** 8 phases from original design (this is phase 5 of 8)

**Codebase verified:** 2026-02-22. Greenfield project. Phase 4 provides ToolRegistry with `generateStubs()` method. Deno 2.6.9 is available on the system.

---

## Acceptance Criteria Coverage

This phase implements and tests:

### machine-spirit-core.AC3: Deno code execution runtime with controlled permissions
- **machine-spirit-core.AC3.1 Success:** Agent can write TypeScript code and execute it in a Deno subprocess
- **machine-spirit-core.AC3.2 Success:** Code can make network requests to hosts on the allowlist
- **machine-spirit-core.AC3.3 Success:** Code can read and write files within the scoped working directory
- **machine-spirit-core.AC3.4 Success:** Code can call host-side tools (memory, etc.) via the IPC bridge and receive results
- **machine-spirit-core.AC3.5 Failure:** Code attempting to spawn subprocesses is denied by Deno permissions
- **machine-spirit-core.AC3.6 Failure:** Code attempting to access environment variables is denied
- **machine-spirit-core.AC3.7 Failure:** Code exceeding the timeout is killed and returns an error to the agent
- **machine-spirit-core.AC3.8 Failure:** Code exceeding max size (50KB) is rejected before execution
- **machine-spirit-core.AC3.9 Edge:** Network requests to hosts not on the allowlist are denied

---

<!-- START_TASK_1 -->
### Task 1: CodeRuntime port types and IPC message types

**Verifies:** None (types only)

**Files:**
- Create: `src/runtime/types.ts`

**Implementation:**

Define the runtime types:

- `ExecutionResult`: `{ success: boolean, output: string, error?: string, tool_calls_made: number, duration_ms: number }`
- `CodeRuntime` port type:
  ```typescript
  type CodeRuntime = {
    execute(code: string, toolStubs: string): Promise<ExecutionResult>;
  };
  ```

IPC message types (shared between host and Deno sides):

- `IpcToolCall`: `{ type: '__tool_call__', name: string, params: Record<string, unknown>, call_id: string }`
- `IpcToolResult`: `{ type: '__tool_result__', call_id: string, result: ToolResult }`
- `IpcToolError`: `{ type: '__tool_error__', call_id: string, error: string }`
- `IpcOutput`: `{ type: '__output__', data: string }`
- `IpcDebug`: `{ type: '__debug__', message: string }`
- `IpcMessage`: discriminated union of all the above

**Verification:**
Run: `bun run build`
Expected: Type-checks without errors

**Commit:** `feat: add CodeRuntime port and IPC message types`
<!-- END_TASK_1 -->

<!-- START_TASK_2 -->
### Task 2: Deno-side IPC bridge runtime

**Verifies:** machine-spirit-core.AC3.4

**Files:**
- Create: `src/runtime/deno/runtime.ts`

**Implementation:**

This file runs inside the Deno subprocess. It:

1. Reads JSON lines from stdin (messages from the Bun host)
2. Provides a `__callTool__` function that sends `__tool_call__` messages to the host and waits for `__tool_result__` responses
3. Provides `output(data)` and `debug(message)` helper functions
4. Imports `TextLineStream` from `jsr:@std/streams`
5. After the bridge is set up, evaluates the user code (the code is appended to this runtime as the last argument or concatenated)

Key implementation details:

**`__callTool__` function:**
- Generates a unique `call_id` (incrementing counter or random string)
- Writes a JSON `__tool_call__` message to stdout
- Waits for a `__tool_result__` or `__tool_error__` message with matching `call_id` from stdin
- Returns the tool result or throws on error
- This creates a synchronous-feeling async call through the IPC channel

**Input handling:**
- The runtime reads from stdin in a loop using `TextLineStream`
- Tool call results are dispatched to pending `__callTool__` promises via a `Map<string, { resolve, reject }>`

**Code execution:**
- The user code + tool stubs are written to a temporary file by the host
- The runtime receives the path to execute, or the code is passed as the script itself
- The approach: The host writes a combined file (runtime bridge + tool stubs + user code) and passes it as the script argument to Deno

**Output capturing:**
- `console.log` in user code should be captured. The runtime wraps output by intercepting console.log to send `__output__` messages instead of printing to stdout (stdout is reserved for IPC)
- Alternatively, stderr can be used for debug output while stdout is for IPC

**Exit:**
- When user code completes (or throws), send a final `__output__` message with the return value or error, then exit

**Verification:**
Run: `deno check src/runtime/deno/runtime.ts`
Expected: Type-checks without errors (Deno's own type checker)

**Commit:** `feat: add Deno-side IPC bridge runtime`
<!-- END_TASK_2 -->

<!-- START_SUBCOMPONENT_A (tasks 3-4) -->
<!-- START_TASK_3 -->
### Task 3: DenoExecutor implementation

**Verifies:** machine-spirit-core.AC3.1, machine-spirit-core.AC3.2, machine-spirit-core.AC3.3, machine-spirit-core.AC3.7, machine-spirit-core.AC3.8

**Files:**
- Create: `src/runtime/executor.ts`

**Implementation:**

Create `createDenoExecutor(config: RuntimeConfig & AgentConfig, registry: ToolRegistry): CodeRuntime` factory function.

The `execute` method:

1. **Size check (AC3.8):** If `code.length > config.max_code_size`, return `ExecutionResult` with `success: false, error: 'Code exceeds max size of ${config.max_code_size} bytes'` immediately — do NOT spawn a subprocess.

2. **Build the script:** Concatenate the Deno runtime bridge code + tool stubs from `registry.generateStubs()` + the user's code. Write this to a temporary file in the working directory.

3. **Build permission flags:**
   ```
   --allow-net=<comma-separated config.allowed_hosts>
   --allow-read=<config.working_dir>,<path to runtime.ts>
   --allow-write=<config.working_dir>
   --deny-run
   --deny-env
   --deny-ffi
   ```

4. **Spawn Deno subprocess:**
   ```typescript
   const proc = Bun.spawn(["deno", "run", ...permissionFlags, scriptPath], {
     stdin: "pipe",
     stdout: "pipe",
     stderr: "pipe",
     cwd: resolve(config.working_dir),
   });
   ```

5. **Set up timeout:** `setTimeout(() => proc.kill(), config.code_timeout)` — if triggered, return `ExecutionResult` with `success: false, error: 'Execution timed out after ${config.code_timeout}ms'`

6. **IPC loop:** Read JSON lines from `proc.stdout`. For each message:
   - `__tool_call__`: Look up tool in registry, call `registry.dispatch()`, write `__tool_result__` or `__tool_error__` back to `proc.stdin`. Increment tool call counter. If counter exceeds `config.max_tool_calls_per_exec`, kill process and return error.
   - `__output__`: Accumulate output string
   - `__debug__`: Log to host console (or ignore)

7. **Output size check:** While accumulating output from `__output__` messages, track total size. If accumulated output exceeds `config.max_output_size` (default 1MB), kill the process and return `ExecutionResult` with `success: false, error: 'Output exceeds max size of ${config.max_output_size} bytes'`.

8. **Wait for exit:** `await proc.exited`. Clear timeout. Clean up temp file.

9. **Return `ExecutionResult`** with accumulated output, success/error status, tool call count, and duration.

**Verification:**
Run: `bun run build`
Expected: Type-checks without errors

**Commit:** `feat: add DenoExecutor with permission flags and IPC`
<!-- END_TASK_3 -->

<!-- START_TASK_4 -->
### Task 4: Code execution runtime tests

**Verifies:** machine-spirit-core.AC3.1, machine-spirit-core.AC3.2, machine-spirit-core.AC3.3, machine-spirit-core.AC3.4, machine-spirit-core.AC3.5, machine-spirit-core.AC3.6, machine-spirit-core.AC3.7, machine-spirit-core.AC3.8, machine-spirit-core.AC3.9

**Files:**
- Test: `src/runtime/executor.test.ts` (integration — requires Deno installed)

**Testing:**

Integration tests that spawn real Deno subprocesses. These require Deno to be installed on the system. Create a test working directory (`workspace/test/`) and clean up after tests.

Create a mock ToolRegistry with a simple test tool (e.g., `echo_tool` that returns its input) for IPC bridge testing.

Tests for each AC:

- **machine-spirit-core.AC3.1:** Execute simple TypeScript code (`const x = 1 + 2; output(String(x))`), verify result is `{ success: true, output: '3' }`
- **machine-spirit-core.AC3.2:** Execute code that fetches from an allowed host (e.g., a simple HEAD request), verify it succeeds. Note: This test may need a reliably available host or could be structured to verify the permission flag is set correctly.
- **machine-spirit-core.AC3.3:** Execute code that writes a file to the working directory, then reads it back. Verify the file exists and contains the expected content. Clean up after.
- **machine-spirit-core.AC3.4:** Execute code that calls a tool via `__callTool__` bridge (using the mock echo_tool), verify the tool was dispatched on the host side and the result was returned to the Deno code.
- **machine-spirit-core.AC3.5:** Execute code that attempts `Deno.Command("ls").spawn()` (or equivalent subprocess call). Verify the execution result contains a permission denied error.
- **machine-spirit-core.AC3.6:** Execute code that attempts `Deno.env.get("PATH")`. Verify the result contains a permission denied error.
- **FFI denied:** Execute code that attempts to load a foreign function library (e.g., `Deno.dlopen()`). Verify the result contains a permission denied error (covered by `--deny-ffi` flag).
- **machine-spirit-core.AC3.7:** Execute code that runs an infinite loop (`while (true) {}`). Configure a short timeout (e.g., 2 seconds). Verify the process is killed and result has `success: false` with timeout error.
- **machine-spirit-core.AC3.8:** Pass code longer than `max_code_size`. Verify the executor rejects it immediately without spawning a subprocess. Result should have `success: false` with size error.
- **machine-spirit-core.AC3.9:** Execute code that attempts to fetch a host NOT on the allowlist. Verify the result contains a permission denied / network error.
- **Output size limit:** Execute code that generates output exceeding `max_output_size` (configure a small limit like 1KB for the test). Verify the process is killed and result has `success: false` with output size error.

**Verification:**
Run: `bun test src/runtime/executor.test.ts`
Expected: All tests pass (requires Deno installed)

**Commit:** `test: add code execution runtime integration tests`
<!-- END_TASK_4 -->
<!-- END_SUBCOMPONENT_A -->
